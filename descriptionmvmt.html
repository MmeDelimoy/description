<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Mouvement du point et vecteurs</title>
    <style>
        body {
            font-family: system-ui, sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            height: 100vh;
            background: #f5f5f5;
        }
        #container {
            margin: auto;
            display: flex;
            gap: 20px;
            align-items: flex-start;
        }
        #canvasWrapper {
            background: white;
            border: 1px solid #ccc;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        canvas {
            display: block;
        }
        #controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-width: 320px;
        }
        .panel {
            background: white;
            border: 1px solid #ccc;
            padding: 10px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            font-size: 0.9em;
        }
        button {
            padding: 6px 10px;
            border-radius: 4px;
            border: 1px solid #888;
            background: #eee;
            cursor: pointer;
            margin: 2px 0;
        }
        button:hover {
            background: #ddd;
        }
        select {
            padding: 4px;
            margin-top: 4px;
        }
        .small {
            font-size: 0.8em;
            color: #555;
        }
        #vectorList {
            max-height: 200px;
            overflow-y: auto;
        }
        .vector-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #eee;
            padding: 2px 0;
            font-size: 0.85em;
        }
        .trash-btn {
            cursor: pointer;
            border: none;
            background: transparent;
            font-size: 1em;
        }
    </style>
</head>
<body>
<div id="container">
    <div id="canvasWrapper">
        <canvas id="scene" width="800" height="600"></canvas>
    </div>

    <div id="controls">
        <div class="panel">
            <p>
                Point rouge: mouvement curviligne en forme de 8, un seul tour quand on appuie sur Play.
            </p>
            <p>
                Position actuelle (m): <span id="posText">(0, 0)</span>
            </p>
            <p>
                Mode: 
                <select id="modeSelect">
                    <option value="position">Vecteur position</option>
                    <option value="deplacement">Vecteur d√©placement</option>
                    <option value="vitesse_inst">Vitesse instantan√©e</option>
                    <option value="vitesse_moy">Vitesse moyenne</option>
                </select>
            </p>
            <p class="small">
                Position / d√©placement: 2 clics (origine puis extr√©mit√©).<br>
                Vitesse instantan√©e: clic sur un point de la trajectoire.<br>
                Vitesse moyenne: 1er clic = position initiale, 2e clic = position finale.
            </p>
        </div>

        <div class="panel">
            <p>Contr√¥les</p>
            <button id="playBtn">Play</button>
            <button id="resetBtn">R√©initialiser</button>
            <button id="axesBtn">Rep√®re: masqu√©</button>
            <p class="small">
                Origine du rep√®re: cliquer pr√®s de O puis d√©placer la souris (quand le rep√®re est visible).<br>
                Graduations en m√®tres (1, 2, 3, ...).
            </p>
        </div>

        <div class="panel">
            <p>Vecteurs cr√©√©s (r, Œîr)</p>
            <div id="vectorList"></div>
            <p class="small">
                Max 6 vecteurs position / d√©placement simultan√©s.<br>
                Utiliser les poubelles pour supprimer un vecteur.
            </p>
        </div>
    </div>
</div>

<script>
    const canvas = document.getElementById('scene');
    const ctx = canvas.getContext('2d');
    const width = canvas.width;
    const height = canvas.height;

    const gridSpacing = 40; // pixels entre lignes
    const scale = gridSpacing; // 1 m = 1 case

    let originX = width / 2;
    let originY = height / 2;

    const posText = document.getElementById('posText');
    const modeSelect = document.getElementById('modeSelect');
    const playBtn = document.getElementById('playBtn');
    const resetBtn = document.getElementById('resetBtn');
    const axesBtn = document.getElementById('axesBtn');
    const vectorListDiv = document.getElementById('vectorList');

    let axesVisible = false;
    let draggingOrigin = false;

    // Trajectoire pr√©-calcul√©e (forme de 8, ind√©pendante du rep√®re)
    const pathSamples = [];
    const T_total_s = 20; // dur√©e "physique" d'un tour, en s
    const N_samples = 1000;

    function buildPath() {
        pathSamples.length = 0;
        for (let i = 0; i < N_samples; i++) {
            const t = (T_total_s * i) / (N_samples - 1); // en s
            const theta = 2 * Math.PI * (t / T_total_s);
            // Courbe en 8 (Lemniscate-like simplifi√©e)
            const x = 4 * Math.cos(theta);
            const y = 2.5 * Math.sin(2 * theta);
            pathSamples.push({ t, x, y });
        }
        // Vitesse instantan√©e par diff√©rence finie
        for (let i = 0; i < N_samples; i++) {
            let im1 = Math.max(0, i - 1);
            let ip1 = Math.min(N_samples - 1, i + 1);
            const dt = pathSamples[ip1].t - pathSamples[im1].t;
            const vx = (pathSamples[ip1].x - pathSamples[im1].x) / dt;
            const vy = (pathSamples[ip1].y - pathSamples[im1].y) / dt;
            const speed = Math.sqrt(vx * vx + vy * vy);
            pathSamples[i].vx = vx;
            pathSamples[i].vy = vy;
            pathSamples[i].speed = speed;
        }
    }

    buildPath();

    // Animation principale
    let loopPlaying = false;
    let loopStartReal = null;
    let currentLoopTime = 0; // en s
    const EPSILON_END = 0.05; // marge de fin de tour

    // Vecteurs position / d√©placement
    let positionCounter = 0;
    let deplacementCounter = 0;
    const maxVectors = 6;
    const vectors = []; // {id, type, name, x1,y1,x2,y2, dx,dy, norm, color}

    // Vitesse instantan√©e (un seul vecteur affich√©)
    let instantVelocityVector = null; // {x, y, vx, vy, speed}

    // Vitesse moyenne: sc√®ne avec chrono
    let avgScene = {
        active: false,
        startIndex: null,
        endIndex: null,
        deltaT: 0,
        deltaX: 0,
        deltaY: 0,
        speed: 0,
        startRealTime: 0
    };
    const PHASE1_DURATION = 4000; // ms
    const PHASE2_DURATION = 3000; // ms

    let mode = 'position';
    let currentVectorStart = null; // pour position / d√©placement

    function pixelToWorld(px, py) {
        const x = (px - originX) / scale;
        const y = (originY - py) / scale;
        return { x, y };
    }

    function worldToPixel(x, y) {
        const px = originX + x * scale;
        const py = originY - y * scale;
        return { px, py };
    }

    function getPositionAtTime(t) {
        // t en s, entre 0 et T_total_s
        if (t <= 0) return pathSamples[0];
        if (t >= T_total_s) return pathSamples[N_samples - 1];
        const u = t / T_total_s;
        const index = u * (N_samples - 1);
        const i0 = Math.floor(index);
        const i1 = Math.min(N_samples - 1, i0 + 1);
        const alpha = index - i0;
        const p0 = pathSamples[i0];
        const p1 = pathSamples[i1];
        const x = p0.x * (1 - alpha) + p1.x * alpha;
        const y = p0.y * (1 - alpha) + p1.y * alpha;
        const vx = p0.vx * (1 - alpha) + p1.vx * alpha;
        const vy = p0.vy * (1 - alpha) + p1.vy * alpha;
        const speed = Math.sqrt(vx * vx + vy * vy);
        return { t, x, y, vx, vy, speed, i0, i1, alpha };
    }

    function getNearestSample(px, py) {
        // renvoie l'index du point de trajectoire le plus proche en pixels
        let bestIndex = 0;
        let bestDist2 = Infinity;
        for (let i = 0; i < pathSamples.length; i++) {
            const p = pathSamples[i];
            const pp = worldToPixel(p.x, p.y);
            const dx = pp.px - px;
            const dy = pp.py - py;
            const d2 = dx * dx + dy * dy;
            if (d2 < bestDist2) {
                bestDist2 = d2;
                bestIndex = i;
            }
        }
        return { index: bestIndex, dist2: bestDist2 };
    }

    function drawGrid() {
        ctx.save();
        ctx.strokeStyle = '#e0e0e0';
        ctx.lineWidth = 1;
        for (let x = 0; x <= width; x += gridSpacing) {
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, height);
            ctx.stroke();
        }
        for (let y = 0; y <= height; y += gridSpacing) {
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(width, y);
            ctx.stroke();
        }
        ctx.restore();
    }

    function drawAxes() {
        if (!axesVisible) return;
        ctx.save();
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = 1.5;

        // Axe x
        ctx.beginPath();
        ctx.moveTo(0, originY);
        ctx.lineTo(width, originY);
        ctx.stroke();

        // Axe y
        ctx.beginPath();
        ctx.moveTo(originX, 0);
        ctx.lineTo(originX, height);
        ctx.stroke();

        // Graduations en m
        ctx.fillStyle = '#000000';
        ctx.font = '10px sans-serif';

        // Axe x graduations et num√©ros
        for (let k = -10; k <= 10; k++) {
            const x = originX + k * scale;
            if (x < 0 || x > width) continue;
            ctx.beginPath();
            ctx.moveTo(x, originY - 4);
            ctx.lineTo(x, originY + 4);
            ctx.stroke();
            if (k !== 0) {
                ctx.fillText(k + ' m', x - 8, originY + 14);
            }
        }

        // Axe y graduations et num√©ros
        for (let k = -10; k <= 10; k++) {
            const y = originY - k * scale;
            if (y < 0 || y > height) continue;
            ctx.beginPath();
            ctx.moveTo(originX - 4, y);
            ctx.lineTo(originX + 4, y);
            ctx.stroke();
            if (k !== 0) {
                ctx.fillText(k + ' m', originX + 6, y + 3);
            }
        }

        // Origine O
        ctx.beginPath();
        ctx.fillStyle = '#ff0000';
        ctx.arc(originX, originY, 6, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#000000';
        ctx.fillText('O', originX + 8, originY - 8);

        ctx.restore();
    }

    function drawArrow(x1, y1, x2, y2, color) {
        const headLength = 10;
        const dx = x2 - x1;
        const dy = y2 - y1;
        const angle = Math.atan2(dy, dx);

        ctx.strokeStyle = color;
        ctx.fillStyle = color;
        ctx.lineWidth = 2;

        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(x2, y2);
        ctx.lineTo(
            x2 - headLength * Math.cos(angle - Math.PI / 6),
            y2 - headLength * Math.sin(angle - Math.PI / 6)
        );
        ctx.lineTo(
            x2 - headLength * Math.cos(angle + Math.PI / 6),
            y2 - headLength * Math.sin(angle + Math.PI / 6)
        );
        ctx.closePath();
        ctx.fill();
    }

    function colorForType(type) {
        if (type === 'position') return '#0074D9';      // bleu
        if (type === 'deplacement') return '#2ECC40';   // vert
        return '#111111';
    }

    function drawVectors() {
        vectors.forEach((v) => {
            const p1 = worldToPixel(v.x1, v.y1);
            const p2 = worldToPixel(v.x2, v.y2);
            drawArrow(p1.px, p1.py, p2.px, p2.py, v.color);
        });
    }

    function drawVectorAnnotations() {
        ctx.save();
        ctx.fillStyle = '#000000';
        ctx.font = '12px sans-serif';

        let baseX = 10;
        let baseY = 20;
        let lineHeight = 34;

        vectors.forEach((v, idx) => {
            if (idx >= maxVectors) return;
            const y0 = baseY + idx * lineHeight;
            const nom = v.type === 'position' ? ('\u2192r\u2090'.replace('\u2090', '') ) : 'Œî\u2192r'; // petite astuce, on va pr√©ciser texte complet √† c√¥t√©
            const label = v.name; // r1, Œîr1...

            const comps = '(' +
                v.dx.toFixed(2) + ' m, ' +
                v.dy.toFixed(2) + ' m)';
            const norme = '| ' + label + ' | ‚âà ' + v.norm.toFixed(2) + ' m';

            ctx.fillText(label + ' : ' + comps, baseX, y0);
            ctx.fillText(norme, baseX, y0 + 14);
        });

        // Vitesse instantan√©e
        if (instantVelocityVector) {
            const yBase = baseY + maxVectors * lineHeight + 10;
            const v = instantVelocityVector;
            ctx.fillText('v_inst : (' +
                v.vx.toFixed(2) + ' m/s, ' +
                v.vy.toFixed(2) + ' m/s)', baseX, yBase);
            ctx.fillText('| v_inst | ‚âà ' + v.speed.toFixed(2) + ' m/s', baseX, yBase + 14);
        }

        ctx.restore();
    }

    function drawInstantVelocityArrow() {
        if (!instantVelocityVector) return;
        const p = instantVelocityVector;
        const pPix = worldToPixel(p.x, p.y);
        const k = 0.8; // √©chelle (m/s -> pixels)
        const x2 = pPix.px + p.vx * scale * k;
        const y2 = pPix.py - p.vy * scale * k;
        drawArrow(pPix.px, pPix.py, x2, y2, '#FF4136');
    }

    function drawAvgSceneOverlay(now) {
        if (!avgScene.active) return;

        const elapsed = now - avgScene.startRealTime; // ms
        const totalScene = PHASE1_DURATION + PHASE2_DURATION;
        if (elapsed > totalScene) {
            avgScene.active = false;
            return;
        }

        const startP = pathSamples[avgScene.startIndex];
        const endP = pathSamples[avgScene.endIndex];
        const startPix = worldToPixel(startP.x, startP.y);
        const endPix = worldToPixel(endP.x, endP.y);

        // Phase 1: d√©placement + chrono
        if (elapsed <= PHASE1_DURATION) {
            const alpha = elapsed / PHASE1_DURATION;
            const currX = startP.x * (1 - alpha) + endP.x * alpha;
            const currY = startP.y * (1 - alpha) + endP.y * alpha;
            const currPix = worldToPixel(currX, currY);

            // mobile √† la position interpol√©e
            drawPointAt(currPix.px, currPix.py);

            // vecteur d√©placement Œîr
            drawArrow(startPix.px, startPix.py, endPix.px, endPix.py, '#FF851B');

            // chrono
            const tChrono = avgScene.deltaT * alpha;
            drawChrono(tChrono, avgScene.deltaT);

            // texte Œîr, Œît
            drawAvgTextsPhase1(tChrono);
        } else {
            // Phase 2: mobile √† la position finale, chrono fig√©, calcul de v_m
            drawPointAt(endPix.px, endPix.py);
            drawChrono(avgScene.deltaT, avgScene.deltaT);
            drawAvgTextsPhase2();
        }
    }

    function drawChrono(tChrono, tFinal) {
        ctx.save();
        const x = width - 180;
        const y = 20;
        const w = 160;
        const h = 50;
        ctx.fillStyle = 'rgba(255,255,255,0.9)';
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.rect(x, y, w, h);
        ctx.fill();
        ctx.stroke();

        ctx.fillStyle = '#000000';
        ctx.font = '12px sans-serif';
        ctx.fillText('Chrono', x + 8, y + 16);
        ctx.fillText('t = ' + tChrono.toFixed(2) + ' s', x + 8, y + 32);
        ctx.fillText('Œît = ' + tFinal.toFixed(2) + ' s', x + 8, y + 46);
        ctx.restore();
    }

    function drawAvgTextsPhase1(tChrono) {
        ctx.save();
        ctx.fillStyle = '#000000';
        ctx.font = '12px sans-serif';
        const baseX = width - 180;
        const baseY = 90;
        ctx.fillText('Sc√®ne vitesse moyenne', baseX, baseY);
        ctx.fillText('Vecteur Œîr affich√©', baseX, baseY + 16);
        ctx.fillText('Chrono en cours: t = ' + tChrono.toFixed(2) + ' s', baseX, baseY + 32);
        ctx.restore();
    }

    function drawAvgTextsPhase2() {
        ctx.save();
        ctx.fillStyle = '#000000';
        ctx.font = '12px sans-serif';
        const baseX = width - 220;
        const baseY = 90;

        const dx = avgScene.deltaX;
        const dy = avgScene.deltaY;
        const dt = avgScene.deltaT;
        const vx = dx / dt;
        const vy = dy / dt;
        const speed = Math.sqrt(vx * vx + vy * vy);

        ctx.fillText('Vecteur v_m :', baseX, baseY);
        ctx.fillText('\u2192v_m = Œî\u2192r / Œît', baseX, baseY + 16);
        ctx.fillText('Œî\u2192r = (' +
            dx.toFixed(2) + ' m, ' +
            dy.toFixed(2) + ' m)', baseX, baseY + 32);
        ctx.fillText('Œît = ' + dt.toFixed(2) + ' s', baseX, baseY + 48);
        ctx.fillText('\u2192v_m = (' +
            vx.toFixed(2) + ' m/s, ' +
            vy.toFixed(2) + ' m/s)', baseX, baseY + 64);
        ctx.fillText('| v_m | ‚âà ' + speed.toFixed(2) + ' m/s', baseX, baseY + 80);

        ctx.restore();
    }

    function drawPointAt(px, py) {
        ctx.save();
        ctx.fillStyle = '#ff0000';
        ctx.beginPath();
        ctx.arc(px, py, 6, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }

    function updateLoopState(now) {
        if (!loopPlaying) return;
        if (!loopStartReal) {
            loopStartReal = now;
        }
        const elapsed = (now - loopStartReal) / 1000; // s
        currentLoopTime = elapsed;
        if (currentLoopTime >= T_total_s - EPSILON_END) {
            currentLoopTime = T_total_s;
            loopPlaying = false;
        }
    }

    function drawScene(now) {
        ctx.clearRect(0, 0, width, height);
        drawGrid();
        drawAxes();

        // Position du mobile (soit dans la sc√®ne moyenne, soit dans le loop)
        let pos;
        if (avgScene.active) {
            // la fonction drawAvgSceneOverlay dessine le mobile
            // on ne dessine pas ici le point principal
        } else {
            // mouvement normal (ou fig√©)
            const t = Math.min(currentLoopTime, T_total_s);
            const p = getPositionAtTime(t);
            pos = p;
            const pix = worldToPixel(p.x, p.y);
            drawPointAt(pix.px, pix.py);

            // texte position
            posText.textContent = '(' +
                p.x.toFixed(2) + ', ' +
                p.y.toFixed(2) + ')';
        }

        // Vecteurs r / Œîr
        drawVectors();

        // Vitesse instantan√©e
        drawInstantVelocityArrow();

        // Annotations pour vecteurs et vitesse instantan√©e
        drawVectorAnnotations();

        // Sc√®ne de vitesse moyenne (par-dessus)
        if (avgScene.active) {
            drawAvgSceneOverlay(now);
        }
    }

    function animate(now) {
        updateLoopState(now);
        drawScene(now);
        requestAnimationFrame(animate);
    }

    requestAnimationFrame(animate);

    // Gestion des clics sur le canvas
    canvas.addEventListener('mousedown', (e) => {
        if (!axesVisible) {
            draggingOrigin = false;
        } else {
            const rect = canvas.getBoundingClientRect();
            const px = e.clientX - rect.left;
            const py = e.clientY - rect.top;
            const dx = px - originX;
            const dy = py - originY;
            const dist2 = dx * dx + dy * dy;
            if (dist2 < 15 * 15) {
                draggingOrigin = true;
                return;
            }
        }
    });

    canvas.addEventListener('mousemove', (e) => {
        if (!draggingOrigin) return;
        const rect = canvas.getBoundingClientRect();
        originX = e.clientX - rect.left;
        originY = e.clientY - rect.top;
    });

    canvas.addEventListener('mouseup', () => {
        draggingOrigin = false;
    });

    canvas.addEventListener('mouseleave', () => {
        draggingOrigin = false;
    });

    canvas.addEventListener('click', (e) => {
        const rect = canvas.getBoundingClientRect();
        const px = e.clientX - rect.left;
        const py = e.clientY - rect.top;

        if (draggingOrigin) return;

        const { index, dist2 } = getNearestSample(px, py);
        const nearThreshold2 = 15 * 15; // clic √† max 15 px de la trajectoire

        mode = modeSelect.value;

        if (mode === 'position' || mode === 'deplacement') {
            // Cr√©ation de vecteurs r ou Œîr √† partir de clics libres (pas forc√©ment sur la trajectoire)
            if (vectors.length >= maxVectors && !currentVectorStart) {
                return; // on limite √† maxVectors vecteurs
            }
            if (!currentVectorStart) {
                currentVectorStart = { px, py };
            } else {
                const p1w = pixelToWorld(currentVectorStart.px, currentVectorStart.py);
                const p2w = pixelToWorld(px, py);
                const dx = p2w.x - p1w.x;
                const dy = p2w.y - p1w.y;
                const norm = Math.sqrt(dx * dx + dy * dy);

                let type = mode;
                let name;
                if (type === 'position') {
                    positionCounter += 1;
                    name = 'r' + positionCounter;
                } else {
                    deplacementCounter += 1;
                    name = 'Œîr' + deplacementCounter;
                }

                const color = colorForType(type);
                vectors.push({
                    id: Date.now() + '_' + Math.random(),
                    type,
                    name,
                    x1: p1w.x,
                    y1: p1w.y,
                    x2: p2w.x,
                    y2: p2w.y,
                    dx,
                    dy,
                    norm,
                    color
                });

                currentVectorStart = null;
                refreshVectorList();
            }
        } else if (mode === 'vitesse_inst') {
            // clic doit √™tre proche de la trajectoire
            if (dist2 > nearThreshold2) {
                return;
            }
            const p = pathSamples[index];
            instantVelocityVector = {
                x: p.x,
                y: p.y,
                vx: p.vx,
                vy: p.vy,
                speed: p.speed
            };
        } else if (mode === 'vitesse_moy') {
            if (dist2 > nearThreshold2) {
                return;
            }
            handleAverageVelocityClick(index);
        }
    });

    function handleAverageVelocityClick(index) {
        // On utilise une petite machine √† √©tats implicite: si avgScene.active, on ignore les clics
        // On m√©morise le premier clic dans currentVectorStartIndex (r√©utilisation)
        if (avgScene.active) return;

        if (currentVectorStart === null || typeof currentVectorStart.index === 'undefined') {
            currentVectorStart = { index };
        } else {
            const i1 = currentVectorStart.index;
            let i2 = index;
            if (i2 <= i1) {
                // si clic en arri√®re, on prend quand m√™me i2 > i1 dans la limite
                if (i1 < pathSamples.length - 2) {
                    i2 = i1 + 1;
                } else {
                    i2 = pathSamples.length - 1;
                }
            }
            const p1 = pathSamples[i1];
            const p2 = pathSamples[i2];
            const dt = p2.t - p1.t;
            const dx = p2.x - p1.x;
            const dy = p2.y - p1.y;
            const speed = Math.sqrt(dx * dx + dy * dy) / dt;

            avgScene = {
                active: true,
                startIndex: i1,
                endIndex: i2,
                deltaT: dt,
                deltaX: dx,
                deltaY: dy,
                speed,
                startRealTime: performance.now()
            };

            currentVectorStart = null;
        }
    }

    function refreshVectorList() {
        vectorListDiv.innerHTML = '';
        vectors.forEach((v) => {
            const item = document.createElement('div');
            item.className = 'vector-item';
            const labelSpan = document.createElement('span');
            labelSpan.textContent = v.name + ' (' + v.type + ')';
            const trashBtn = document.createElement('button');
            trashBtn.className = 'trash-btn';
            trashBtn.textContent = 'üóë';
            trashBtn.addEventListener('click', () => {
                const idx = vectors.findIndex((vv) => vv.id === v.id);
                if (idx !== -1) {
                    vectors.splice(idx, 1);
                    refreshVectorList();
                }
            });
            item.appendChild(labelSpan);
            item.appendChild(trashBtn);
            vectorListDiv.appendChild(item);
        });
    }

    // Boutons
    playBtn.addEventListener('click', () => {
        loopPlaying = true;
        loopStartReal = performance.now();
        currentLoopTime = 0;
    });

    resetBtn.addEventListener('click', () => {
        loopPlaying = false;
        loopStartReal = null;
        currentLoopTime = 0;
        vectors.length = 0;
        instantVelocityVector = null;
        avgScene.active = false;
        positionCounter = 0;
        deplacementCounter = 0;
        currentVectorStart = null;
        originX = width / 2;
        originY = height / 2;
        refreshVectorList();
    });

    axesBtn.addEventListener('click', () => {
        axesVisible = !axesVisible;
        axesBtn.textContent = axesVisible ? 'Rep√®re: affich√©' : 'Rep√®re: masqu√©';
    });
</script>
</body>
</html>
